<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Algorithm::DecisionTree - A pure-Perl implementation for
constructing a decision tree from multidimensional training
data and for using the decision tree thus induced for
classifying data.</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#changes">CHANGES</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#what_practical_problem_is_solved_by_this_module">WHAT PRACTICAL PROBLEM IS SOLVED BY THIS MODULE</a></li>
	<li><a href="#what_happens_if_the_number_of_features_and_or_values_is_large">WHAT HAPPENS IF THE NUMBER OF FEATURES AND/OR VALUES IS LARGE</a></li>
	<li><a href="#what_happens_when_the_feature_values_are_numeric">WHAT HAPPENS WHEN THE FEATURE VALUES ARE NUMERIC</a></li>
	<li><a href="#methods">METHODS</a></li>
	<li><a href="#how_the_classification_results_are_displayed">HOW THE CLASSIFICATION RESULTS ARE DISPLAYED</a></li>
	<li><a href="#examples">EXAMPLES</a></li>
	<li><a href="#export">EXPORT</a></li>
	<li><a href="#bugs">BUGS</a></li>
	<li><a href="#installation">INSTALLATION</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>Algorithm::DecisionTree - A pure-Perl implementation for
constructing a decision tree from multidimensional training
data and for using the decision tree thus induced for
classifying data.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  # FOR CONSTRUCTING A DECISION TREE AND FOR CLASSIFYING A SAMPLE:</pre>
<pre>
      my $training_datafile = &quot;training.dat&quot;;
      my $dt = Algorithm::DecisionTree-&gt;new( 
                               training_datafile =&gt; $training_datafile,
                               debug1 =&gt; 1,
      );
      $dt-&gt;get_training_data();
      $dt-&gt;show_training_data();
      my $root_node = $dt-&gt;construct_decision_tree_classifier();
      $root_node-&gt;display_decision_tree(&quot;   &quot;);
      my @test_sample = qw /exercising=&gt;never 
                            smoking=&gt;heavy 
                            fatIntake=&gt;heavy 
                            videoAddiction=&gt;heavy /;
      $dt-&gt;classify($root_node, @test_sample);</pre>
<pre>
  # For the above calls to work, the format in which the training data is made
  # available to the decision-tree constructor new() must meet certain
  # assumptions.  (See the training.dat file in the examples directory.)  The
  # training datafile must declare the class names, the feature names and the
  # names of the different possible values for the features.  The rest of the
  # training datafile is expected to contain the training samples in the form of
  # a multi-column table.</pre>
<pre>
  # HIGHLY RECOMMENDED: Always use the &quot;debug1&quot; option in the constructor call
  # above when working with a training dataset for the first time.</pre>
<pre>
  # If your training file specifies a large number of features or a large
  # number of values for the features, the above constructor call could result
  # in a decision tree that is simply much too large (and much too slow to
  # construct).  For such cases, consider using following additional options in
  # the constructor call shown above:</pre>
<pre>
      my $dt = Algorithm::DecisionTree-&gt;new( 
                               training_datafile =&gt; $training_datafile,
                               max_depth_desired =&gt; some_number,
                               entropy_threshold =&gt; some_value,
                               debug1 =&gt; 1,
      );
  
  # where for max_depth_desired you should choose a number that is less than the
  # number of features in your training file. This will set the depth of your
  # decision tree to max_depth_desired. The algorithm will automatically use the
  # BEST max_depth_desired features --- best in the sense of being the most
  # discriminative --- for constructing the decision tree.  The parameter
  # entropy_threshold sets the granularity with which the entropies will be
  # sampled.  Its default value is 0.001.  The larger the value you choose for
  # entropy_threshold, the smaller the tree.</pre>
<pre>
  # FOR GENERATING TRAINING DATA:</pre>
<pre>
      use Algorithm::DecisionTree;
      my $parameter_file = &quot;param.txt&quot;;
      my $output_data_file = &quot;training.dat&quot;;
      my $training_data_gen = Algorithm::DecisionTree-&gt;training_data_generator( 
                                  output_datafile =&gt; $output_data_file,
                                  parameter_file    =&gt; $parameter_file,
                                  number_of_training_samples =&gt; 35,
      );
      $training_data_gen-&gt;read_parameter_file();
      $training_data_gen-&gt;gen_training_data();
      $training_data_gen-&gt;write_training_data_to_file();</pre>
<pre>
  # For the above calls to work, the parameter file must obey certain
  # assumptions.  (See the param.txt file in the examples directory.) The
  # parameter file must declare the class names, the class priors, the feature
  # names and the different possible values for the features.  The parameter
  # file is also expected to present information on how you want the data
  # vectors to be biased for the different classes.</pre>
<pre>
  # FOR GENERATING TEST DATA:</pre>
<pre>
      use Algorithm::DecisionTree;
      my $parameter_file = &quot;param.txt&quot;;
      my $output_test_datafile = &quot;testdata.dat&quot;;
      my $output_class_label_file = &quot;test_data_class_labels.dat&quot;;
      my $test_data_gen = Algorithm::DecisionTree-&gt;test_data_generator(
                   output_test_datafile    =&gt; $output_test_datafile,
                   output_class_label_file =&gt; $output_class_label_file,
                   parameter_file          =&gt; $parameter_file,
                   write_to_file           =&gt; 1,
                   number_of_test_samples  =&gt; 10,
                   debug1                  =&gt; 1,
      );
      $test_data_gen-&gt;read_parameter_file();
      $test_data_gen-&gt;gen_test_data();
      $test_data_gen-&gt;write_test_data_to_file();</pre>
<pre>
  # The test data is deposited without the class labels in the file named for
  # the parameter output_test_datafile.  The class labels are deposited in a
  # separate file named for the parameter output_class_label_file.  The class
  # names, the feature names, the feature values, and the probabilistic bias
  # used for the test data are according to the information placed in the
  # parameter file.</pre>
<p>
</p>
<hr />
<h1><a name="changes">CHANGES</a></h1>
<p>Some of the key elements of the documentation were cleaned
up and made more readable in Version 1.41.  The
implementation code remains unchanged from Version 1.4.</p>
<p>Version 1.4 should make things faster (and easier) for folks
who want to use this module with training data that creates
very large decision trees (that is, trees with tens of
thousands or more decision nodes).  The speedup in Version
1.4 has been achieved by eliminating duplicate calculation
of probabilities as the tree grows.  In addition, this
version provides an additional constructor parameter,
<code>max_depth_desired</code> for controlling the size of the
decisiotn tree.  This is in addition to the tree size
control achieved by the parameter <code>entropy_threshold</code> that
was introduced in Version 1.3.  Since large decision trees
can take a long time to create, you may find yourself
wishing you could store the tree you just created in a disk
file and that, subsequently, you could use the stored tree
for classification work.  The <code>examples</code> directory contains
two scripts, <code>store_dt_on_disk.pl</code> and
<code>classify_from_disk_stored_dt.pl</code>, that show how you can do
exactly that with the help of Perl's <code>Storable</code> module.</p>
<p>Version 1.3 addresses the issue that arises when the header
of a training datafile declares a certain possible value for
a feature but that (feature,value) pair does NOT show up
anywhere in the training data.  Version 1.3 also makes it
possible for a user to control the size of the decision tree
by changing the value of the parameter <code>entropy_threshold.</code>
Additionally, Version 1.3 includes a method called
<a href="#determine_data_condition"><code>determine_data_condition()</code></a> that displays useful
information regarding the size and some other attributes of
the training data.  It also warns the user if the training
data might result in a decision tree that would simply be
much too large --- unless the user controls the size with
the entropy_threshold parameter.</p>
<p>In addition to the removal of a couple of serious bugs,
version 1.2 incorporates a number of enhancements: (1)
Version 1.2 includes checks on the names of the features and
values used in test data --- this is the data you want to
classify with the decision tree classifier constructed by
this module.  (2) Version 1.2 includes a separate
constructor for generating test data.  To make it easier to
generate test data whose probabilistic parameters may not be
identical to that used for the training data, I have used
separate routines for generating the test data.  (3) Version
1.2 also includes in its examples directory a script that
classifies the test data in a file and outputs the class
labels into another file.  This is for folks who do not wish
to write their own scripts using this module. (4) Version
1.2 also includes addition to the documentation regarding
the issue of numeric values for features.</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p><strong>Algorithm::DecisionTree</strong> is a <em>perl5</em> module for
constructing a decision tree from a training datafile
containing multidimensional data.  In one form or another,
decision trees have been around for about fifty years. But
their popularity during the last decade is owing to the
entropy-based method proposed by Ross Quinlan for their
construction.  Fundamental to Quinlan's approach is the
notion that a decision node in a tree should be split only
if the entropy at the ensuing child nodes will be less than
the entropy at the node in question.  The implementation
presented here is based on the same idea.</p>
<p>For those not familiar with decision tree ideas, the
traditional way to classify multidimensional data is to
start with a feature space whose dimensionality is the same
as that of the data.  Each feature in this space would
correspond to the attribute that each dimension of the data
measures.  You then use the training data to carve up the
feature space into different regions, each corresponding to
a different class.  Subsequently, when you are trying to
classify a new data sample, you locate it in the feature
space and find the class label of the region to which it
belongs.  One can also give the data point the same class
label as that of the nearest training sample.  (This is
referred to as the nearest neighbor classification.)</p>
<p>A decision tree classifier works differently.  When you
construct a decision tree, you select for the root node a
feature test that can be expected to maximally
disambiguate the class labels that could be associated with
the data you are trying to classify.  You then attach to the
root node a set of child nodes, one for each value of the
feature you chose at the root node. Now at each child node
you pose the same question that you posed when you found the
best feature to use at the root node: What feature at the
child node in question would maximally disambiguate the
class labels to be associated with a given data vector
assuming that the data vector passed the root node on the
branch that corresponds to the child node in question.  The
feature that is best at each node is the one that causes the
maximal reduction in class entropy at that node.</p>
<p>As the reader would expect, the two key steps in any
approach to decision-tree based classification are the
construction of the decision tree itself from a file
containing the training data, and then using the decision
tree thus obtained for classifying the data.</p>
<p>In addition to the above two key steps, the implementation
presented here also allows you to generate your own training
data. Generating your own training data, using it for
constructing a decision-tree classifier and subsequently
testing the classifier on a test set of data is a good way
to develop greater proficiency with decision trees.</p>
<p>What is cool about decision tree classification is that it
gives you soft classification, meaning it may associate more
than one class label with a given data vector.  When this
happens, it may mean that your classes are indeed
overlapping in the underlying feature space.  It could also
mean that you simply have not supplied sufficient training
data to the decision tree classifier.  For a tutorial
introduction to how a decision tree is constructed and used,
visit
<a href="http://cobweb.ecn.purdue.edu/~kak/DecisionTreeClassifiers.pdf">http://cobweb.ecn.purdue.edu/~kak/DecisionTreeClassifiers.pdf</a></p>
<p>
</p>
<hr />
<h1><a name="what_practical_problem_is_solved_by_this_module">WHAT PRACTICAL PROBLEM IS SOLVED BY THIS MODULE</a></h1>
<p>Consider the following scenario: Let's say you are running a
small investment company that employs a team of
stockbrokers who make buy/sell decisions for the customers
of your company.  Assume that your company has asked the
traders to make each investment decision on the basis of the
following four criteria:</p>
<pre>
  price_to_earnings_ratio   (P_to_E)</pre>
<pre>
  price_to_sales_ratio      (P_to_S)</pre>
<pre>
  return_on_equity          (R_on_E)</pre>
<pre>
  market_share              (MS)</pre>
<p>Since you are the boss, you keep track of the buy/sell
decisions made by the individual traders.  But one
unfortunate day, all of your traders decide to quit because
you did not pay them enough.  So what do you do?  If you had
a module like the one here, you could still run your company
and do so in such a way that, on the average, would do
better than any of the individual traders who worked for
your company.  This is what you do: You pool together the
individual trader buy/sell decisions you have accumulated
during the last one year.  This pooled information is likely
to look like:</p>
<pre>
  example      buy/sell     P_to_E     P_to_S     R_on_E      MS
  ============================================================+=</pre>
<pre>
  example_1     buy          high       low        medium    low
  example_2     buy          medium     medium     low       low
  example_3     sell         low        medium     low       high
  ....
  ....</pre>
<p>This data would constitute your training file. You could feed this
file into the module by calling:</p>
<pre>
    my $dt = Algorithm::DecisionTree-&gt;new( 
                                          training_datafile =&gt; $training_datafile,
                                         );
    $dt-&gt;get_training_data();</pre>
<p>and then construct a decision tree by calling:</p>
<pre>
    my $root_node = $dt-&gt;construct_decision_tree_classifier();</pre>
<p>Now you and your company (with practically no employees) are
ready to service the customers again. Suppose your computer
needs to make a buy/sell decision about an investment
prospect that is best described by:</p>
<pre>
    price_to_earnings_ratio   =&gt;  low
    price_to_sales_ratio      =&gt;  very_low
    return_on_equity          =&gt;  none
    market_share              =&gt;  medium</pre>
<p>All that your computer would need to do would be to
construct a data vector like</p>
<pre>
   my @data =   qw / P_to_E=&gt;low
                     P_to_S=&gt;very_low
                     R_on_E=&gt;none
                     MS=&gt;medium /;</pre>
<p>and call the decision tree classifier you just constructed by</p>
<pre>
    $dt-&gt;classify($root_node, @data);</pre>
<p>The answer returned will be 'buy' and 'sell', along with the
associated probabilities.  So if the probability of 'buy' is
considerably greater than the probability of 'sell', that's
what you should instruct your computer to do.</p>
<p>The chances are that, on the average, this approach would
beat the performance of any of your individual traders who
worked for you previously since the buy/sell decisions made
by the computer would be based on the collective wisdom of
all your previous traders.  <strong>DISCLAIMER: There is obviously
a lot more to good investing than what is captured by the
silly little example here. However, it does the convey the
sense in which the current module could be used.</strong></p>
<p>
</p>
<hr />
<h1><a name="what_happens_if_the_number_of_features_and_or_values_is_large">WHAT HAPPENS IF THE NUMBER OF FEATURES AND/OR VALUES IS LARGE</a></h1>
<p>If <code>n</code> is the number of features and <code>m</code> the largest
number for the possible values for any of the features,
then, <strong>in only the worst case</strong>, the algorithm would want to
construct <code>m**n</code> nodes.  In other words, in the worst case,
the size of the decision tree grows exponentially as you
increase either the number of features or the number of
possible values for the features.  That is the bad news.
The <strong>good news</strong> is that you have two constructor parameters
at your disposal for controlling the size of the decision
tree: The parameter <code>max_depth_desired</code> controls the depth
of the constructed tree from its root node, and the
parameter <code>entropy_threshold</code> controls the granularity with
which the entropy space will be sampled.  The smaller the
<code>max_depth_desired</code> and the larger the
<code>entropy_threshold</code>, the smaller the size of the decision
tree.  The default value for <code>max_depth_desired</code> is the
number of features specified in the training datafile, and
the the default value for <code>entropy_threshold</code> is 0.001.</p>
<p>The users of this module with a need to create very large
decision trees should also consider storing the tree once
constructed in a diskfile and then using the stored tree for
classification work.  The scripts <code>store_dt_on_disk.pl</code> and
<code>classify_from_disk_stored_dt.pl</code> in the <code>examples</code>
directory show you how you can do that with the help of
Perl's Storable module.</p>
<p><strong>Also note that it is always a good idea to keep the
<code>debug1</code> option set anytime you are experimenting with a
new datafile</strong> --- especially if your training datafile is
likely to create an inordinately large decision tree.</p>
<p>
</p>
<hr />
<h1><a name="what_happens_when_the_feature_values_are_numeric">WHAT HAPPENS WHEN THE FEATURE VALUES ARE NUMERIC</a></h1>
<p>The current module will treat a numeric value for a feature
as just a string.  In that sense, there is no difference
between a string value for a feature and a numeric value.
This would obviously make the module unsuitable for
applications in which a feature may take on a numeric value
from a very large set of such values and you want feature
values to be compared using numeric comparison predicates as
opposed to string comparison predicates.  (Consider, for
example, using color as an object feature in a computer
vision application.)  The decision trees for applications in
which the feature values are primarily numerical in nature
are constructed differently, as explained in the tutorial at
<a href="http://cobweb.ecn.purdue.edu/~kak/DecisionTreeClassifiers.pdf">http://cobweb.ecn.purdue.edu/~kak/DecisionTreeClassifiers.pdf</a></p>
<p>
</p>
<hr />
<h1><a name="methods">METHODS</a></h1>
<p>The module provides the following methods for decision-tree
induction from training data in a diskfile, for data
classification with the decision tree, and for generating
your own training data:</p>
<dl>
<dt><strong><a name="new" class="item"><strong>new():</strong></a></strong></dt>

<dd>
<pre>
    my $dt = Algorithm::DecisionTree-&gt;new( 
                                          training_datafile =&gt; $training_datafile,
                                         );</pre>
<p>A call to <a href="#new"><code>new()</code></a> constructs a new instance of the
<code>Algorithm::DecisionTree</code> class.  For this call to make
sense, the training data in the training datafile must be
according to a certain format that is shown below.  (Also
see the file <code>training.dat</code> in the <code>examples</code> directory.)</p>
</dd>
<dt><strong><a name="get_training_data" class="item"><strong>get_training_data():</strong></a></strong></dt>

<dd>
<p>After you have constructed a new instance of the <code>Algorithm::DecisionTree</code>
class, you must now read in the training data that is contained in the
file named above.  This you do by:</p>
<pre>
    $dt-&gt;get_training_data();</pre>
<p>IMPORTANT: The training data file must in a format that
makes sense to the decision tree constructor.  The
information in this file should look like</p>
<pre>
    Class names: malignant benign</pre>
<pre>
    Feature names and their values:
        videoAddiction =&gt; none low medium heavy
        exercising =&gt; never occasionally regularly
        smoking =&gt; heavy medium light never
        fatIntake =&gt; low medium heavy</pre>
<pre>
    Training Data:</pre>
<pre>
    sample     class      videoAddiction   exercising    smoking   fatIntake
    ==========================================================================</pre>
<pre>
    sample_0   benign     medium           occasionally  heavy     low
    sample_1   malignant  none             occasionally  heavy     medium
    sample_2   benign     low              occasionally  light     heavy
    sample_3   malignant  medium           occasionally  heavy     heavy
    ....
    ....</pre>
<p>IMPORTANT: Note that the class names, the number of classes,
the feature names, and the possible values for the features
can be anything that your data requires them to be.  The
training data file that is generated by the data generation
part of the module will be in the format shown above.  More
on that later.</p>
</dd>
<dt><strong><a name="show_training_data" class="item"><strong>show_training_data():</strong></a></strong></dt>

<dd>
<p>If you wish to see the training data that was just digested by the module,
call</p>
<pre>
    $dt-&gt;show_training_data();</pre>
</dd>
<dt><strong><a name="construct_decision_tree_classifier" class="item"><strong>construct_decision_tree_classifier():</strong></a></strong></dt>

<dd>
<p>After the training data is digested, it is time to construct 
a decision tree classifier.  This you do by</p>
<pre>
    my $root_node = $dt-&gt;construct_decision_tree_classifier();</pre>
<p>This call returns an instance of type <code>Node</code>.  The <code>Node</code>
class is defined within the main package file, at its end.
So, don't forget, that <code>$root_node</code> in the above example
call will be instantiated to an instance of type <code>Node</code>.</p>
</dd>
<dt><strong><a name="display_decision_tree" class="item"><strong>$root_node<code>-&gt;</code>display_decision_tree(&quot; &quot;):</strong></a></strong></dt>

<dd>
<pre>
    $root_node-&gt;display_decision_tree(&quot;   &quot;);</pre>
<p>This will display the decision tree in your terminal window
by using a recursively determined offset for each node as
the display routine descends down the tree.</p>
<p>I have intentionally left the syntax fragment <code>$root_node</code>
in the above call to remind the reader that
<a href="#display_decision_tree"><code>display_decision_tree()</code></a> is NOT called on the instance of
the <code>DecisionTree</code> we constructed earlier, but on the
<code>Node</code> instance returned by the call to
<a href="#construct_decision_tree_classifier"><code>construct_decision_tree_classifier()</code></a>.</p>
</dd>
<dt><strong><a name="classify" class="item"><strong>classify($root_node, @test_sample):</strong></a></strong></dt>

<dd>
<pre>
    my @test_sample = qw /exercising=&gt;never 
                          smoking=&gt;heavy 
                          fatIntake=&gt;heavy 
                          videoAddiction=&gt;heavy /;</pre>
<pre>
    my $classification = $dt-&gt;classify($root_node, @test_sample);</pre>
<p>where, again, <code>$root_node</code> is an instance of type <code>Node</code>
returned by the call to
<a href="#construct_decision_tree_classifier"><code>construct_decision_tree_classifier()</code></a>.  The variable
<code>$classification</code> holds a reference to a hash whose keys are
the class labels and whose values the associated
probabilities.</p>
</dd>
<dt><strong><a name="determine_data_condition" class="item"><strong>determine_data_condition():</strong></a></strong></dt>

<dd>
<p>This method, automatically invoked when <code>debug1</code> option is set
in the call to the decision-tree constructor, displays
useful information regarding your training data file.  This
method also warns you if you are trying to construct a
decision tree that may simply be much too large.</p>
<pre>
    $dt-&gt;determine_data_condition();</pre>
</dd>
<dt><strong><a name="training_data_generator" class="item"><strong>training_data_generator():</strong></a></strong></dt>

<dd>
<p>The training data generator is created by using its own constructor:</p>
<pre>
    my $parameter_file = &quot;param2.txt&quot;;
    my $output_data_file = &quot;training.dat&quot;;
    my $training_data_gen = Algorithm::DecisionTree-&gt;training_data_generator( 
                              output_datafile =&gt; $output_data_file,
                              parameter_file    =&gt; $parameter_file,
                              number_of_training_samples =&gt; 35,
    );</pre>
</dd>
<dt><strong><a name="read_parameter_file" class="item"><strong>$training_data_gen<code>-&gt;</code>read_parameter_file():</strong></a></strong></dt>

<dd>
<p>After you have constructed an instance of the training data
generator, you need to ask it to read the parameter file:</p>
<pre>
    $training_data_gen-&gt;read_parameter_file();</pre>
<p>The parameter file is expected to be in the following format:</p>
<pre>
    # comment lines begin with the hash mark</pre>
<pre>
    class names:  malignant benign
    class priors: 0.4 0.6</pre>
<pre>
    feature: smoking
    values: heavy medium light never</pre>
<pre>
    feature: exercising
    values: never occasionally regularly</pre>
<pre>
    feature: fatIntake
    values: low medium heavy</pre>
<pre>
    feature: videoAddiction
    values:  none low medium heavy</pre>
<pre>
    bias:  class: malignant</pre>
<pre>
          smoking:    heavy=0.7
          exercising: never=0.7 
          fatIntake:  heavy=0.5
          videoAddiction:</pre>
<pre>
    bias:  class: benign</pre>
<pre>
          smoking:     heavy=0.1
          exercising:  regularly=0.7
          fatIntake:   low=0.6
          videoAddiction:</pre>
<p>See the parameter file <code>param.txt</code> in the <code>examples</code> directory.
Initially, it might be best to modify that file to suit your
needs.</p>
<p>IMPORTANT: You can use any names for the classes, can have
any number of classes, can use any names for the features
and their values.</p>
<p>Also note the the important role played by the biasing
information.  Without the biasing, your training data will
be uniformly distributed with respect to all of the feature
values and you will only get ambiguous classifications from
the resulting decision tree classifier.  The biasing allows
you to express a higher or lower probability that a
particular feature value should have for a given class.  The
probability weight that is unused for each feature is
distributed uniformly amongst the remaining feature values.
I did experiment with the idea of assigning probability
weights to multiple (or even all) of the values for a given
feature --- it does not add to the educational value you
derive from the resulting training data.</p>
<p>NOTE: if you do NOT express a bias for a feature (as is the
case with the feature <code>videoAddiction</code> above), equal weight
is given to all its values.</p>
</dd>
<dt><strong><a name="gen_training_data" class="item"><strong>$training_data_gen<code>-&gt;</code>gen_training_data():</strong></a></strong></dt>

<dd>
<p>This call generators the training data from your parameter
file:</p>
<pre>
    $training_data_gen-&gt;gen_training_data();</pre>
</dd>
<dt><strong><a name="write_training_data_to_file" class="item"><strong>$training_data_gen<code>-&gt;</code>write_training_data_to_file():</strong></a></strong></dt>

<dd>
<p>To write out the training data to a disk file:</p>
<pre>
    $training_data_gen-&gt;write_training_data_to_file();</pre>
<p>This call will also display the training data in your
terminal window if the <code>debug1</code> option is set in the
training data generator constructor.</p>
</dd>
<dt><strong><a name="test_data_generator" class="item"><strong>test_data_generator():</strong></a></strong></dt>

<dd>
<p>The test data is generated by using its own constructor:</p>
<pre>
    my $parameter_file = &quot;param.txt&quot;;
    my $output_test_datafile = &quot;testdata1.dat&quot;;
    my $output_class_label_file = &quot;test_data_class_labels.dat&quot;;</pre>
<pre>
    my $test_data_gen = Algorithm::DecisionTree-&gt;test_data_generator(
                       output_test_datafile    =&gt; $output_test_datafile,
                       output_class_label_file =&gt; $output_class_label_file,
                       parameter_file          =&gt; $parameter_file,
                       write_to_file           =&gt; 1,
                       number_of_test_samples  =&gt; 10,
    );</pre>
</dd>
<dt><strong><strong>$test_data_gen<code>-&gt;</code>read_parameter_file():</strong></strong></dt>

<dd>
<p>After you have constructed an instance of the test data
generator, you need to ask it to read the parameter file.</p>
<pre>
    $test_data_gen-&gt;read_parameter_file();</pre>
<p>This parameter file named in the call to the test-data
generator constructor must possess the same structure as for
generating the training data.  In most cases, you would want
to use the same paramter file both for generating the training
data and the test data.</p>
</dd>
<dt><strong><a name="gen_test_data" class="item"><strong>$test_data_gen<code>-&gt;</code>gen_test_data():</strong></a></strong></dt>

<dd>
<p>This call generates the test data from your parameter file:</p>
<pre>
    $training_data_gen-&gt;gen_training_data();</pre>
</dd>
<dt><strong><a name="write_test_data_to_file" class="item"><strong>$test_data_gen<code>-&gt;</code>write_test_data_to_file():</strong></a></strong></dt>

<dd>
<p>To write out the test data to a disk file:</p>
<pre>
    $test_data_gen-&gt;write_test_data_to_file();</pre>
<p>This call will also display the test data in your terminal
window if the <code>debug1</code> option is set in the test data
generator constructor.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="how_the_classification_results_are_displayed">HOW THE CLASSIFICATION RESULTS ARE DISPLAYED</a></h1>
<p>It depends on whether you apply the classifier at once to
all the data samples in a file, or whether you feed one data
sample at a time into the classifier.</p>
<p>For large test datasets, you would obviously want to process
an entire file of test data at a time.  The best way to do
this is to follow my script</p>
<pre>
    classify_test_data_in_a_file.pl</pre>
<p>in the examples directly.  This script requires three
command-line arguments, the first argument names the
training datafile, the second the test datafile, and the
third in which the classification results will be deposited.</p>
<p>You can also invoke the classifier on one data sample at a
time.  A call such as</p>
<pre>
    my @test_sample = qw /exercising=&gt;never 
                          smoking=&gt;heavy 
                          fatIntake=&gt;heavy 
                          videoAddiction=&gt;heavy /;</pre>
<pre>
    my $classification = $dt-&gt;classify($root_node, @test_sample);
    print &quot;The classification:\n&quot;;
    foreach my $class ($dt-&gt;get_class_names()) {
        print &quot;    $class with probability $classification-&gt;{$class}\n&quot;; 
    }</pre>
<p>will print out the classification results in the following form:</p>
<pre>
    The classification:
        malignant with probability 0.744186046511628
        benign with probability 0.255813953488372</pre>
<p>Note again the soft classification returned.  That is, if
the probability distributions for the different classes
overlap in the underlying feature space, the classifier will
return all of the applicable class labels for a data vector
along with the corresponding class probabilities.  Another
reason for why the decision tree classifier may associate
significant probabilities with multiple class labels is that
you used inadequate number of training samples to induce the
decision tree.  <strong>The good thing is that the classifier does
not lie to you</strong> (unlike, say, a hard classification rule
that would corresponding to a partitioning of the underlying
feature space).  The decision tree classifier give you the
best classification that can be made given the training data
you fed into it.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>See the <code>examples</code> directory in the distribution for how to
generate the training data, how to induce a decision tree,
and how to then classify new data using the decision tree.</p>
<p>To become more familiar with the module, run the script</p>
<pre>
    training_data_generator.pl</pre>
<p>to generate a training datafile according to the information
placed in the file param.txt.  Then run the script</p>
<pre>
    construct_dt_and_classify_one_sample.pl</pre>
<p>to classify a new data sample that is in the script.  Next
generate a test dataset by calling</p>
<pre>
    generate_test_data.pl*</pre>
<p>This will deposit the test data in a file.  You can invoke the
classifier on this file by an invocation like</p>
<pre>
    classify_test_data_in_a_file.pl   training.dat   testdata.dat   out.txt</pre>
<p>This call will first construct a decision tree using the
training data in the file <code>training.dat</code>.  It will then
calculate the class label for each data vector in the file
<code>testdata.dat</code>.  The estimated class labels will be written
out to the file <code>out.txt</code>.</p>
<p>The <code>examples</code> directory also contains the script
<code>store_dt_on_disk.pl</code> that shows how you can use Perl's
Storable module to store a decision tree in a disk file.
The file <code>classify_from_disk_stored_dt.pl</code> in the same
directory shows how you can classify new data vectors with
the stored decision tree.  This is expected to be extremely
useful for situations that involve tens of thousands or
millions of decision nodes.</p>
<p>
</p>
<hr />
<h1><a name="export">EXPORT</a></h1>
<p>None by design.</p>
<p>
</p>
<hr />
<h1><a name="bugs">BUGS</a></h1>
<p>Please notify the author if you encounter any bugs.  When
sending email, please place the string 'DecisionTree' in the
subject line.</p>
<p>
</p>
<hr />
<h1><a name="installation">INSTALLATION</a></h1>
<p>The usual</p>
<pre>
    perl Makefile.PL
    make
    make test
    make install</pre>
<p>if you have root access.  If not,</p>
<pre>
    perl Makefile.PL prefix=/some/other/directory/
    make
    make test
    make install</pre>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Avinash Kak, <a href="mailto:kak@purdue.edu">kak@purdue.edu</a></p>
<p>If you send email, please place the string &quot;DecisionTree&quot; in your
subject line to get past my spam filter.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</p>
<pre>
 Copyright 2011 Avinash Kak

</pre>

</body>

</html>
